//#include <stdio.h>
//#include <stdlib.h>
//
//// 프로세스 노드 구조체 정의
//typedef struct ProcessNode {
//    int data;
//    struct ProcessNode* next;
//} ProcessNode;
//
//// 스택 노드 구조체 정의
//typedef struct StackNode {
//    ProcessNode* processList;
//    struct StackNode* next;
//} StackNode;
//
//// 새로운 프로세스 노드를 생성하고 리스트에 추가 (리스트의 끝에 삽입)
//void insertProcess(ProcessNode** head, int data) {
//    ProcessNode* newNode = (ProcessNode*)malloc(sizeof(ProcessNode));
//    newNode->data = data;
//    newNode->next = NULL;
//
//    if (*head == NULL) {
//        *head = newNode;
//    }
//    else {
//        ProcessNode* current = *head;
//        while (current->next != NULL) {
//            current = current->next;
//        }
//        current->next = newNode;
//    }
//}
//
//// 새로운 스택 노드를 생성하고 스택에 추가
//void push(StackNode** top, ProcessNode* processList) {
//    StackNode* newNode = (StackNode*)malloc(sizeof(StackNode));
//    newNode->processList = processList;
//    newNode->next = *top;
//    *top = newNode;
//}
//
//// 스택의 맨 위 노드를 제거하고 해당 노드의 프로세스 리스트를 반환
//ProcessNode* pop(StackNode** top) {
//    if (*top == NULL) {
//        printf("스택이 비어 있습니다.\n");
//        return NULL;
//    }
//    StackNode* temp = *top;
//    ProcessNode* processList = temp->processList;
//    *top = (*top)->next;
//    free(temp);
//    return processList;
//}
//
//// 프로세스 리스트 출력
//void printProcessList(ProcessNode* head) {
//    ProcessNode* current = head;
//    while (current != NULL) {
//        printf("%d -> ", current->data);
//        current = current->next;
//    }
//    printf("NULL\n");
//}
//
//// 스택 출력
//void printStack(StackNode* top) {
//    StackNode* current = top;
//    while (current != NULL) {
//        printf("스택 노드의 프로세스 리스트: ");
//        printProcessList(current->processList);
//        current = current->next;
//    }
//}
//
//// 프로세스 리스트 메모리 해제
//void freeProcessList(ProcessNode* head) {
//    ProcessNode* current = head;
//    while (current != NULL) {
//        ProcessNode* temp = current;
//        current = current->next;
//        free(temp);
//    }
//}
//
//// 스택 메모리 해제
//void freeStack(StackNode* top) {
//    StackNode* current = top;
//    while (current != NULL) {
//        StackNode* temp = current;
//        freeProcessList(current->processList);
//        current = current->next;
//        free(temp);
//    }
//}
//
//void dispatchProcess(StackNode** top) {
//    if (*top == NULL) {
//        printf("스택이 비어 있습니다.\n");
//        return;
//    }
//    // top 스택 노드의 프로세스 리스트의 첫 번째 노드를 가져옴
//    ProcessNode* head = (*top)->processList;
//    if (head == NULL) {
//        printf("프로세스 리스트가 비어 있습니다.\n");
//        return;
//    }
//    // 첫 번째 노드 삭제
//    ProcessNode* temp = head;
//    (*top)->processList = head->next;
//    free(temp);
//
//    // 삭제 후 리스트가 비어 있으면 스택에서 해당 노드를 제거
//    if ((*top)->processList == NULL) {
//        StackNode* tempStackNode = *top;
//        *top = (*top)->next;
//        free(tempStackNode);
//    }
//}
//
//void promote(StackNode** top, StackNode* P) {
//    if (P == NULL || *top == NULL || P->processList == NULL) {
//        printf("Promotion을 수행할 수 없습니다.\n");
//        return;
//    }
//
//    // P의 프로세스 리스트에서 첫 번째 노드를 제거하고 저장
//    ProcessNode* nodeToPromote = P->processList;
//    P->processList = P->processList->next;
//    nodeToPromote->next = NULL; // 이동될 노드는 단독 노드가 됨
//
//    // P가 스택의 맨 위 노드라면, 스택의 맨 아래에 추가
//    if (P->next == NULL) {
//        StackNode* current = *top;
//        while (current->next != NULL) {
//            current = current->next;
//        }
//        // 새 스택 노드 생성 및 연결
//        StackNode* newStackNode = (StackNode*)malloc(sizeof(StackNode));
//        newStackNode->processList = nodeToPromote;
//        newStackNode->next = NULL;
//        current->next = newStackNode;
//    }
//    else {
//        // P 다음 스택 노드의 프로세스 리스트의 끝에 추가
//        StackNode* nextStackNode = P->next;
//        ProcessNode* currentProcess = nextStackNode->processList;
//        if (currentProcess == NULL) {
//            // 다음 스택 노드의 프로세스 리스트가 비어 있다면 바로 연결
//            nextStackNode->processList = nodeToPromote;
//        }
//        else {
//            // 프로세스 리스트의 끝을 찾아 연결
//            while (currentProcess->next != NULL) {
//                currentProcess = currentProcess->next;
//            }
//            currentProcess->next = nodeToPromote;
//        }
//    }
//
//    // 원래 리스트가 비어 있으면 스택 노드를 제거
//    if (P->processList == NULL) {
//        // P가 top이면 특별 처리
//        if (P == *top) {
//            *top = P->next;
//        }
//        else {
//            // P의 이전 노드 찾기
//            StackNode* prev = *top;
//            while (prev != NULL && prev->next != P) {
//                prev = prev->next;
//            }
//            if (prev != NULL) {
//                prev->next = P->next;
//            }
//        }
//        free(P);
//    }
//}
//
//// 프로세스 리스트의 길이를 반환하는 함수
//int processListLength(ProcessNode* head) {
//    int count = 0;
//    ProcessNode* current = head;
//    while (current != NULL) {
//        count++;
//        current = current->next;
//    }
//    return count;
//}
//
//// 스택의 노드 수를 반환하는 함수
//int stackNodeCount(StackNode* top) {
//    int count = 0;
//    StackNode* current = top;
//    while (current != NULL) {
//        count++;
//        current = current->next;
//    }
//    return count;
//}
//
//// 전체 프로세스의 개수를 반환하는 함수
//int totalProcessCount(StackNode* top) {
//    int total = 0;
//    StackNode* current = top;
//    while (current != NULL) {
//        total += processListLength(current->processList);
//        current = current->next;
//    }
//    return total;
//}
//
//// split_n_merge 함수 구현
//void split_n_merge(StackNode** top) {
//    if (*top == NULL) return;
//
//    int totalProcesses = totalProcessCount(*top);
//    int stackNodes = stackNodeCount(*top);
//    int threshold = totalProcesses / stackNodes;
//
//    StackNode* currentStackNode = *top;
//    while (currentStackNode != NULL) {
//        int listLength = processListLength(currentStackNode->processList);
//        // 리스트 길이가 threshold보다 큰 경우 분할 및 병합 수행
//        if (listLength > threshold) {
//            ProcessNode* currentProcess = currentStackNode->processList;
//            ProcessNode* midPrevProcess = NULL;
//            // 중간 지점 찾기
//            for (int i = 0; i < 
//                / 2 - 1; i++) {
//                currentProcess = currentProcess->next;
//            }
//            midPrevProcess = currentProcess;
//            currentProcess = currentProcess->next; // 중간 지점의 노드
//            midPrevProcess->next = NULL; // 앞쪽 절반 분리
//
//            // 상위 리스트에 병합
//            if (currentStackNode->next == NULL) { // 최상위 리스트인 경우
//                push(top, currentProcess); // 새 스택 노드로 추가
//            }
//            else {
//                // 상위 리스트의 끝에 붙임
//                ProcessNode* tail = currentStackNode->next->processList;
//                if (tail == NULL) {
//                    currentStackNode->next->processList = currentProcess;
//                }
//                else {
//                    while (tail->next != NULL) {
//                        tail = tail->next;
//                    }
//                    tail->next = currentProcess;
//                }
//            }
//            // 재귀적으로 threshold 검사 및 분할 병합 수행
//            split_n_merge(top);
//            return; // 분할 후에는 더 이상 현재 레벨에서 진행하지 않음
//        }
//        currentStackNode = currentStackNode->next;
//    }
//}
//
//// 메인 함수
//int main() {
//    StackNode* stack = NULL;
//
//    // 첫 번째 스택 노드에 프로세스 리스트 추가
//    ProcessNode* processList1 = NULL;
//    insertProcess(&processList1, 1);
//    insertProcess(&processList1, 2);
//    insertProcess(&processList1, 3);
//    push(&stack, processList1);
//
//    // 두 번째 스택 노드에 프로세스 리스트 추가
//    ProcessNode* processList2 = NULL;
//    insertProcess(&processList2, 4);
//    insertProcess(&processList2, 5);
//    push(&stack, processList2);
//
//    // 세 번째 스택 노드에 프로세스 리스트 추가
//    ProcessNode* processList3 = NULL;
//    insertProcess(&processList3, 6);
//    insertProcess(&processList3, 7);
//    push(&stack, processList3);
//
//    // 스택 출력
//    printf("초기 스택 상태:\n");
//    printStack(stack);
//
//    // dispatchProcess 함수 호출
//    printf("\nDispatch 프로세스 실행 후:\n");
//    dispatchProcess(&stack);
//    printStack(stack);
//
//    // promote 함수 호출 예시
//    // 여기서는 P를 두 번째 스택 노드로 설정하여 promote를 수행합니다.
//    printf("\nPromote 실행 후:\n");
//    promote(&stack, stack->next); // stack->next는 두 번째 노드를 가리킵니다.
//    printStack(stack);
//
//    // 메모리 해제
//    freeStack(stack);
//
//    return 0;
//}